"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.initPassportDataParsing = initPassportDataParsing;
exports.generateCommitment = generateCommitment;
exports.generateNullifier = generateNullifier;
exports.pad = pad;
exports.padWithZeroes = padWithZeroes;
exports.getPassportSignatureInfos = getPassportSignatureInfos;
exports.getCertificatePubKey = getCertificatePubKey;
exports.formatCertificatePubKeyDSC = formatCertificatePubKeyDSC;
exports.extractSignatureFromDSC = extractSignatureFromDSC;
exports.formatSignatureDSCCircuit = formatSignatureDSCCircuit;
exports.findStartPubKeyIndex = findStartPubKeyIndex;
exports.getSignatureAlgorithmFullName = getSignatureAlgorithmFullName;
exports.getPubKeyBytes = getPubKeyBytes;
exports.extractRSFromSignature = extractRSFromSignature;
exports.getNAndK = getNAndK;
exports.getNAndKCSCA = getNAndKCSCA;
const poseidon_lite_1 = require("poseidon-lite");
const constants_1 = require("../../constants/constants");
const parseCertificateSimple_1 = require("../certificate_parsing/parseCertificateSimple");
const parsePassportData_1 = require("./passport_parsing/parsePassportData");
const shaPad_1 = require("../shaPad");
const shaPad_2 = require("../shaPad");
const hash_1 = require("../hash");
const bytes_1 = require("../bytes");
const hash_2 = require("../hash");
const forge = __importStar(require("node-forge"));
const constants_2 = require("../../constants/constants");
const bytes_2 = require("../bytes");
const format_1 = require("./format");
const csca_1 = require("../csca");
const generateInputs_1 = require("../circuits/generateInputs");
const trees_1 = require("../trees");
/// @dev will bruteforce passport and dsc signature
function initPassportDataParsing(passportData) {
    const passportMetadata = (0, parsePassportData_1.parsePassportData)(passportData);
    passportData.passportMetadata = passportMetadata;
    const dscParsed = (0, parseCertificateSimple_1.parseCertificateSimple)(passportData.dsc);
    passportData.dsc_parsed = dscParsed;
    if (passportData.passportMetadata.csca) {
        const cscaParsed = (0, parseCertificateSimple_1.parseCertificateSimple)(passportData.passportMetadata.csca);
        passportData.csca_parsed = cscaParsed;
    }
    return passportData;
}
function generateCommitment(secret, attestation_id, passportData) {
    const passportMetadata = passportData.passportMetadata;
    const dg1_packed_hash = (0, hash_2.packBytesAndPoseidon)((0, format_1.formatMrz)(passportData.mrz));
    const eContent_shaBytes = (0, hash_1.hash)(passportMetadata.eContentHashFunction, Array.from(passportData.eContent), 'bytes');
    const eContent_packed_hash = (0, hash_2.packBytesAndPoseidon)(eContent_shaBytes.map((byte) => byte & 0xff));
    const dsc_hash = (0, trees_1.getLeafDscTree)(passportData.dsc_parsed, passportData.csca_parsed);
    return (0, poseidon_lite_1.poseidon5)([
        secret,
        attestation_id,
        dg1_packed_hash,
        eContent_packed_hash,
        dsc_hash,
    ]).toString();
}
function generateNullifier(passportData) {
    const signedAttr_shaBytes = (0, hash_1.hash)(passportData.passportMetadata.signedAttrHashFunction, Array.from(passportData.signedAttr), 'bytes');
    const signedAttr_packed_hash = (0, hash_2.packBytesAndPoseidon)(signedAttr_shaBytes.map((byte) => byte & 0xff));
    return signedAttr_packed_hash;
}
function pad(hashFunction) {
    return hashFunction === 'sha1' || hashFunction === 'sha224' || hashFunction === 'sha256'
        ? shaPad_1.shaPad
        : shaPad_2.sha384_512Pad;
}
function padWithZeroes(bytes, length) {
    return bytes.concat(new Array(length - bytes.length).fill(0));
}
/// @notice Get the signature of the passport and the public key of the DSC
/// @dev valid for only for the passport/dsc chain
function getPassportSignatureInfos(passportData) {
    const passportMetadata = passportData.passportMetadata;
    const signatureAlgorithmFullName = getSignatureAlgorithmFullName(passportData.dsc_parsed, passportMetadata.signatureAlgorithm, passportMetadata.signedAttrHashFunction);
    const { n, k } = getNAndK(signatureAlgorithmFullName);
    return {
        pubKey: getCertificatePubKey(passportData.dsc_parsed, passportMetadata.signatureAlgorithm, passportMetadata.signedAttrHashFunction),
        signature: getPassportSignature(passportData, n, k),
        signatureAlgorithmFullName: signatureAlgorithmFullName,
    };
}
function getPassportSignature(passportData, n, k) {
    const { signatureAlgorithm } = passportData.dsc_parsed;
    if (signatureAlgorithm === 'ecdsa') {
        const { r, s } = extractRSFromSignature(passportData.encryptedDigest);
        const signature_r = (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(r)), n, k);
        const signature_s = (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(s)), n, k);
        return [...signature_r, ...signature_s];
    }
    else {
        return (0, bytes_2.splitToWords)(BigInt((0, bytes_1.bytesToBigDecimal)(passportData.encryptedDigest)), n, k);
    }
}
/// @notice Get the public key from the certificate
/// @dev valid for both DSC and CSCA
function getCertificatePubKey(certificateData, signatureAlgorithm, hashFunction) {
    const signatureAlgorithmFullName = getSignatureAlgorithmFullName(certificateData, signatureAlgorithm, hashFunction);
    const { n, k } = getNAndK(signatureAlgorithmFullName);
    const { publicKeyDetails } = certificateData;
    if (signatureAlgorithm === 'ecdsa') {
        const { x, y } = publicKeyDetails;
        const x_dsc = (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(x)), n, k);
        const y_dsc = (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(y)), n, k);
        return [...x_dsc, ...y_dsc];
    }
    else {
        const { modulus } = publicKeyDetails;
        return (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(modulus)), n, k);
    }
}
/// @notice Get the public key from the certificate padded as per the DSC circuit's requirements.
function formatCertificatePubKeyDSC(certificateData, signatureAlgorithm) {
    const { publicKeyDetails } = certificateData;
    if (signatureAlgorithm === 'ecdsa') {
        const { x, y } = publicKeyDetails;
        // const normalizedX = x.length % 2 === 0 ? x : '0' + x;
        // const normalizedY = y.length % 2 === 0 ? y : '0' + y;
        const fullPubKey = x + y;
        // Splits to 525 words of 8 bits each
        return (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(fullPubKey)), 8, 525);
    }
    else {
        // Splits to 525 words of 8 bits each
        const { modulus } = publicKeyDetails;
        return (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(modulus)), 8, 525);
    }
}
function extractSignatureFromDSC(dscCertificate) {
    const cert = (0, parseCertificateSimple_1.getCertificateFromPem)(dscCertificate);
    const dscSignature = cert.signatureValue.valueBlock.valueHexView;
    return Array.from(forge.util.createBuffer(dscSignature).getBytes(), (char) => char.charCodeAt(0));
}
function formatSignatureDSCCircuit(cscaSignatureAlgorithm, cscaHashFunction, cscaCertificateData, signature) {
    const cscaSignatureAlgorithmFullName = getSignatureAlgorithmFullName(cscaCertificateData, cscaSignatureAlgorithm, cscaHashFunction);
    const { n, k } = getNAndK(cscaSignatureAlgorithmFullName);
    if (cscaSignatureAlgorithm === 'ecdsa') {
        const { r, s } = extractRSFromSignature(signature);
        const signature_r = (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(r)), n, k);
        const signature_s = (0, bytes_2.splitToWords)(BigInt((0, bytes_1.hexToDecimal)(s)), n, k);
        return [...signature_r, ...signature_s];
    }
    else {
        return (0, generateInputs_1.formatInput)((0, bytes_2.splitToWords)(BigInt((0, bytes_1.bytesToBigDecimal)(signature)), n, k));
    }
}
function findStartPubKeyIndex(certificateData, rawCert, signatureAlgorithm) {
    const { publicKeyDetails } = certificateData;
    if (signatureAlgorithm === 'ecdsa') {
        const { x, y } = publicKeyDetails;
        const [x_index, x_totalLength] = (0, csca_1.findStartIndexEC)(x, rawCert);
        const [y_index, y_totalLength] = (0, csca_1.findStartIndexEC)(y, rawCert);
        return [x_index, x_totalLength + y_totalLength];
    }
    else {
        // Splits to 525 words of 8 bits each
        const { modulus } = publicKeyDetails;
        return (0, csca_1.findStartIndex)(modulus, rawCert);
    }
}
/// @notice Get the signature algorithm full name
/// @dev valid for both DSC and CSCA
function getSignatureAlgorithmFullName(certificateData, signatureAlgorithm, hashAlgorithm) {
    const { publicKeyDetails } = certificateData;
    if (signatureAlgorithm === 'ecdsa') {
        return `${signatureAlgorithm}_${hashAlgorithm}_${publicKeyDetails.curve}_${publicKeyDetails.bits}`;
    }
    else {
        const { exponent } = publicKeyDetails;
        return `${signatureAlgorithm}_${hashAlgorithm}_${exponent}_${publicKeyDetails.bits}`;
    }
}
/*** retrieve pubKey bytes - will be used in generateCircuitsInputsCSCA ***/
function getPubKeyBytes(passportData, type) {
    if (type === 'dsc') {
        return getDscPubKeyBytes(passportData);
    }
    else if (type === 'csca') {
        return getCscaPubKeyBytes(passportData);
    }
    else {
        throw new Error('Invalid type');
    }
}
function getDscPubKeyBytes(passportData) {
    const signatureAlgorithm = passportData.passportMetadata.signatureAlgorithm;
    if (signatureAlgorithm === 'ecdsa') {
        return getECDSAPubKeyBytes(passportData.dsc_parsed);
    }
    return getRsaPubKeyBytes(passportData.dsc_parsed);
}
function getCscaPubKeyBytes(passportData) {
    if (!passportData.passportMetadata.cscaFound) {
        throw new Error('CSCA not found');
    }
    const signatureAlgorithm = passportData.passportMetadata.cscaSignatureAlgorithm;
    if (signatureAlgorithm === 'ecdsa') {
        throw new Error('ECDSA signature algorithm not supported for CSCA');
    }
    return getRsaPubKeyBytes(passportData.dsc);
}
function getRsaPubKeyBytes(parsedCertificate) {
    const pubKeyHex = parsedCertificate.publicKeyDetails.modulus;
    return hexToBytes(pubKeyHex);
}
function getECDSAPubKeyBytes(parsedCertificate) {
    const { x, y } = parsedCertificate.publicKeyDetails;
    const pubKeyBytes = [...hexToBytes(x), ...hexToBytes(y)];
    return pubKeyBytes;
}
function padPubKeyBytes(pubKeyBytes) {
    const paddedPubKeyBytes = pubKeyBytes.concat(new Array(constants_1.MAX_PUBKEY_DSC_BYTES - pubKeyBytes.length).fill(0));
    return paddedPubKeyBytes;
}
function hexToBytes(hex) {
    // Remove '0x' prefix if present
    const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
    const paddedHex = cleanHex.length % 2 ? '0' + cleanHex : cleanHex;
    const bytes = [];
    for (let i = 0; i < paddedHex.length; i += 2) {
        bytes.push(parseInt(paddedHex.slice(i, i + 2), 16));
    }
    return bytes;
}
function extractRSFromSignature(signatureBytes) {
    const derSignature = Buffer.from(signatureBytes).toString('binary');
    const asn1 = forge.asn1.fromDer(derSignature);
    const signatureAsn1 = asn1.value;
    if (signatureAsn1.length !== 2) {
        throw new Error('Invalid signature format');
    }
    if (!Array.isArray(asn1.value) || asn1.value.length !== 2) {
        throw new Error('Invalid signature format');
    }
    const r = forge.util.createBuffer(asn1.value[0].value).toHex();
    const s = forge.util.createBuffer(asn1.value[1].value).toHex();
    return { r, s };
}
function getNAndK(sigAlg) {
    if (sigAlg === 'rsa_sha256_65537_3072') {
        return { n: constants_2.n_dsc_3072, k: constants_2.k_dsc }; // 3072/32 = 96
    }
    if (sigAlg.startsWith('ecdsa_')) {
        if (sigAlg.endsWith('224')) {
            return { n: 32, k: 7 };
        }
        else if (sigAlg.endsWith('256')) {
            return { n: constants_2.n_dsc_ecdsa, k: 4 };
        }
        else if (sigAlg.endsWith('384')) {
            return { n: constants_2.n_dsc_ecdsa, k: 6 };
        }
        else if (sigAlg.endsWith('512')) {
            return { n: constants_2.n_dsc_ecdsa, k: 8 };
        }
        else if (sigAlg.endsWith('521')) {
            return { n: 66, k: 8 };
        }
        else {
            throw new Error('invalid key size');
        }
    }
    if (sigAlg.startsWith('rsapss_')) {
        const keyLength = parseInt(sigAlg.split('_')[3]);
        if (keyLength === 3072) {
            return { n: constants_2.n_dsc_3072, k: constants_2.k_dsc_3072 }; // 3072/32 = 96
        }
        if (keyLength === 4096) {
            return { n: constants_2.n_dsc_4096, k: constants_2.k_dsc_4096 }; // 4096/32 = 128
        }
        return { n: constants_2.n_dsc, k: constants_2.k_dsc }; // 2048/32 = 64
    }
    if (sigAlg === 'rsa_sha256_65537_4096' || sigAlg === 'rsa_sha512_65537_4096') {
        return { n: constants_2.n_dsc_4096, k: constants_2.k_dsc_4096 }; // 4096/32 = 128
    }
    return { n: constants_2.n_dsc, k: constants_2.k_dsc }; // 2048/32 = 64
}
function getNAndKCSCA(sigAlg) {
    const n = sigAlg === 'ecdsa' ? constants_2.n_dsc_ecdsa : constants_2.n_csca;
    const k = sigAlg === 'ecdsa' ? constants_2.k_dsc_ecdsa : constants_2.k_csca;
    return { n, k };
}
