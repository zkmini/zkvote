"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.genMockPassportData = genMockPassportData;
const forge = __importStar(require("node-forge"));
const asn1 = __importStar(require("asn1js"));
const elliptic_1 = __importDefault(require("elliptic"));
const hash_1 = require("../hash");
const mockCertificates = __importStar(require("../../constants/mockCertificates"));
const parseCertificateSimple_1 = require("../certificate_parsing/parseCertificateSimple");
const curves_1 = require("../certificate_parsing/curves");
const format_1 = require("./format");
const format_2 = require("./format");
const passport_1 = require("./passport");
function generateRandomBytes(length) {
    // Generate numbers between -128 and 127 to match the existing signed byte format
    return Array.from({ length }, () => Math.floor(Math.random() * 256) - 128);
}
function generateDataGroupHashes(mrzHash, hashLen) {
    // Generate hashes for DGs 2-15 (excluding some DGs that aren't typically used)
    const dataGroups = [
        [1, mrzHash], // DG1 must be the MRZ hash
        [2, generateRandomBytes(hashLen)],
        [3, generateRandomBytes(hashLen)],
        [4, generateRandomBytes(hashLen)],
        [5, generateRandomBytes(hashLen)],
        [7, generateRandomBytes(hashLen)],
        [8, generateRandomBytes(hashLen)],
        // [11, generateRandomBytes(hashLen)],
        // [12, generateRandomBytes(hashLen)],
        // [14, generateRandomBytes(hashLen)],
        [15, generateRandomBytes(hashLen)],
    ];
    return dataGroups;
}
function genMockPassportData(dgHashAlgo, eContentHashAlgo, signatureType, nationality, birthDate, expiryDate, passportNumber = '15AA81234', lastName = 'DUPONT', firstName = 'ALPHONSE HUGHUES ALBERT') {
    if (birthDate.length !== 6 || expiryDate.length !== 6) {
        throw new Error('birthdate and expiry date have to be in the "YYMMDD" format');
    }
    // Prepare last name: Convert to uppercase, remove invalid characters, split by spaces, and join with '<'
    const lastNameParts = lastName
        .toUpperCase()
        .replace(/[^A-Z< ]/g, '')
        .split(' ');
    const formattedLastName = lastNameParts.join('<');
    // Prepare first name: Convert to uppercase, remove invalid characters, split by spaces, and join with '<'
    const firstNameParts = firstName
        .toUpperCase()
        .replace(/[^A-Z< ]/g, '')
        .split(' ');
    const formattedFirstName = firstNameParts.join('<');
    // Build the first line of MRZ
    let mrzLine1 = `P<${nationality}${formattedLastName}<<${formattedFirstName}`;
    // Pad the first line with '<' to make it exactly 44 characters
    mrzLine1 = mrzLine1.padEnd(44, '<');
    if (mrzLine1.length > 44) {
        throw new Error('First line of MRZ exceeds 44 characters');
    }
    // Build the second line of MRZ
    const mrzLine2 = `${passportNumber}4${nationality}${birthDate}1M${expiryDate}5<<<<<<<<<<<<<<02`;
    // Combine both lines to form the MRZ
    const mrz = mrzLine1 + mrzLine2;
    // Validate the MRZ length
    if (mrz.length !== 88) {
        throw new Error(`MRZ must be 88 characters long, got ${mrz.length}`);
    }
    let privateKeyPem;
    let dsc;
    switch (signatureType) {
        case 'rsa_sha1_65537_2048':
            privateKeyPem = mockCertificates.mock_dsc_sha1_rsa_65537_2048_key;
            dsc = mockCertificates.mock_dsc_sha1_rsa_65537_2048;
            break;
        case 'rsa_sha1_65537_4096':
            privateKeyPem = mockCertificates.mock_dsc_sha1_rsa_65537_4096_key;
            dsc = mockCertificates.mock_dsc_sha1_rsa_65537_4096;
            break;
        case 'rsa_sha256_65537_2048':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsa_65537_2048_key;
            dsc = mockCertificates.mock_dsc_sha256_rsa_65537_2048;
            break;
        case 'rsapss_sha256_65537_2048':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsapss_32_65537_2048_key;
            dsc = mockCertificates.mock_dsc_sha256_rsapss_32_65537_2048;
            break;
        case 'rsapss_sha256_65537_2048_64':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsapss_64_65537_2048_key;
            dsc = mockCertificates.mock_dsc_sha256_rsapss_64_65537_2048;
            break;
        case 'rsapss_sha256_3_2048':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsapss_32_3_2048_key;
            dsc = mockCertificates.mock_dsc_sha256_rsapss_32_3_2048;
            break;
        case 'rsapss_sha256_3_3072':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsapss_32_3_3072_key;
            dsc = mockCertificates.mock_dsc_sha256_rsapss_32_3_3072;
            break;
        case 'rsapss_sha384_65537_3072':
            privateKeyPem = mockCertificates.mock_dsc_sha384_rsapss_48_65537_3072_key;
            dsc = mockCertificates.mock_dsc_sha384_rsapss_48_65537_3072;
            break;
        case 'rsapss_sha384_65537_2048':
            privateKeyPem = mockCertificates.mock_dsc_sha384_rsapss_48_65537_2048_key;
            dsc = mockCertificates.mock_dsc_sha384_rsapss_48_65537_2048;
            break;
        case 'ecdsa_sha256_secp256r1_256':
            privateKeyPem = mockCertificates.mock_dsc_sha256_ecdsa_secp256r1_key;
            dsc = mockCertificates.mock_dsc_sha256_ecdsa_secp256r1;
            break;
        case 'ecdsa_sha1_secp256r1_256':
            privateKeyPem = mockCertificates.mock_dsc_sha1_ecdsa_secp256r1_key;
            dsc = mockCertificates.mock_dsc_sha1_ecdsa_secp256r1;
            break;
        case 'ecdsa_sha384_secp384r1_384':
            privateKeyPem = mockCertificates.mock_dsc_sha384_ecdsa_secp384r1_key;
            dsc = mockCertificates.mock_dsc_sha384_ecdsa_secp384r1;
            break;
        case 'ecdsa_sha256_secp384r1_384':
            privateKeyPem = mockCertificates.mock_dsc_sha256_ecdsa_secp384r1_key;
            dsc = mockCertificates.mock_dsc_sha256_ecdsa_secp384r1;
            break;
        case 'ecdsa_sha1_brainpoolP256r1_256':
            privateKeyPem = mockCertificates.mock_dsc_sha1_ecdsa_brainpoolP256r1_key;
            dsc = mockCertificates.mock_dsc_sha1_ecdsa_brainpoolP256r1;
            break;
        case 'ecdsa_sha256_brainpoolP256r1_256':
            privateKeyPem = mockCertificates.mock_dsc_sha256_ecdsa_brainpoolP256r1_key;
            dsc = mockCertificates.mock_dsc_sha256_ecdsa_brainpoolP256r1;
            break;
        case 'ecdsa_sha384_brainpoolP256r1_256':
            privateKeyPem = mockCertificates.mock_dsc_sha384_ecdsa_brainpoolP256r1_key;
            dsc = mockCertificates.mock_dsc_sha384_ecdsa_brainpoolP256r1;
            break;
        case 'ecdsa_sha512_brainpoolP256r1_256':
            privateKeyPem = mockCertificates.mock_dsc_sha512_ecdsa_brainpoolP256r1_key;
            dsc = mockCertificates.mock_dsc_sha512_ecdsa_brainpoolP256r1;
            break;
        case 'rsa_sha256_3_2048':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsa_3_2048_key;
            dsc = mockCertificates.mock_dsc_sha256_rsa_3_2048;
            break;
        case 'rsa_sha256_65537_3072':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsa_65537_3072_key;
            dsc = mockCertificates.mock_dsc_sha256_rsa_65537_3072;
            break;
        case 'rsapss_sha256_65537_3072':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsapss_32_65537_3072_key;
            dsc = mockCertificates.mock_dsc_sha256_rsapss_32_65537_3072;
            break;
        case 'rsapss_sha256_65537_4096':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsapss_32_65537_4096_key;
            dsc = mockCertificates.mock_dsc_sha256_rsapss_32_65537_4096;
            break;
        case 'ecdsa_sha256_brainpoolP384r1_384':
            privateKeyPem = mockCertificates.mock_dsc_sha256_ecdsa_brainpoolP384r1_key;
            dsc = mockCertificates.mock_dsc_sha256_ecdsa_brainpoolP384r1;
            break;
        case 'ecdsa_sha384_brainpoolP384r1_384':
            privateKeyPem = mockCertificates.mock_dsc_sha384_ecdsa_brainpoolP384r1_key;
            dsc = mockCertificates.mock_dsc_sha384_ecdsa_brainpoolP384r1;
            break;
        case 'ecdsa_sha512_brainpoolP384r1_384':
            privateKeyPem = mockCertificates.mock_dsc_sha512_ecdsa_brainpoolP384r1_key;
            dsc = mockCertificates.mock_dsc_sha512_ecdsa_brainpoolP384r1;
            break;
        case 'ecdsa_sha1_brainpoolP224r1_224':
            privateKeyPem = mockCertificates.mock_dsc_sha1_ecdsa_brainpoolP224r1_key;
            dsc = mockCertificates.mock_dsc_sha1_ecdsa_brainpoolP224r1;
            break;
        case 'ecdsa_sha224_brainpoolP224r1_224':
            privateKeyPem = mockCertificates.mock_dsc_sha224_ecdsa_brainpoolP224r1_key;
            dsc = mockCertificates.mock_dsc_sha224_ecdsa_brainpoolP224r1;
            break;
        case 'ecdsa_sha256_brainpoolP224r1_224':
            privateKeyPem = mockCertificates.mock_dsc_sha256_ecdsa_brainpoolP224r1_key;
            dsc = mockCertificates.mock_dsc_sha256_ecdsa_brainpoolP224r1;
            break;
        case 'ecdsa_sha384_brainpoolP512r1_512':
            privateKeyPem = mockCertificates.mock_dsc_sha384_ecdsa_brainpoolP512r1_key;
            dsc = mockCertificates.mock_dsc_sha384_ecdsa_brainpoolP512r1;
            break;
        case 'ecdsa_sha512_brainpoolP512r1_512':
            privateKeyPem = mockCertificates.mock_dsc_sha512_ecdsa_brainpoolP512r1_key;
            dsc = mockCertificates.mock_dsc_sha512_ecdsa_brainpoolP512r1;
            break;
        case 'ecdsa_sha512_secp521r1_521':
            privateKeyPem = mockCertificates.mock_dsc_sha512_ecdsa_secp521r1_key;
            dsc = mockCertificates.mock_dsc_sha512_ecdsa_secp521r1;
            break;
        case 'ecdsa_sha256_secp521r1_521':
            privateKeyPem = mockCertificates.mock_dsc_sha256_ecdsa_secp521r1_key;
            dsc = mockCertificates.mock_dsc_sha256_ecdsa_secp521r1;
            break;
        case 'rsa_sha256_65537_4096':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsa_65537_4096_key;
            dsc = mockCertificates.mock_dsc_sha256_rsa_65537_4096;
            break;
        case 'rsa_sha512_65537_4096':
            privateKeyPem = mockCertificates.mock_dsc_sha512_rsa_65537_4096_key;
            dsc = mockCertificates.mock_dsc_sha512_rsa_65537_4096;
            break;
        case 'rsa_sha512_65537_2048':
            privateKeyPem = mockCertificates.mock_dsc_sha512_rsa_65537_2048_key;
            dsc = mockCertificates.mock_dsc_sha512_rsa_65537_2048;
            break;
        case 'rsa_sha256_3_4096':
            privateKeyPem = mockCertificates.mock_dsc_sha256_rsa_3_4096_key;
            dsc = mockCertificates.mock_dsc_sha256_rsa_3_4096;
            break;
        case 'rsa_sha384_65537_4096':
            privateKeyPem = mockCertificates.mock_dsc_sha384_rsa_65537_4096_key;
            dsc = mockCertificates.mock_dsc_sha384_rsa_65537_4096;
            break;
        case 'rsapss_sha512_65537_4096':
            privateKeyPem = mockCertificates.mock_dsc_sha512_rsapss_64_65537_4096_key;
            dsc = mockCertificates.mock_dsc_sha512_rsapss_64_65537_4096;
            break;
        case 'rsapss_sha512_65537_2048':
            privateKeyPem = mockCertificates.mock_dsc_sha512_rsapss_64_65537_2048_key;
            dsc = mockCertificates.mock_dsc_sha512_rsapss_64_65537_2048;
            break;
        case 'ecdsa_sha224_secp224r1_224':
            privateKeyPem = mockCertificates.mock_dsc_sha224_ecdsa_secp224r1_key;
            dsc = mockCertificates.mock_dsc_sha224_ecdsa_secp224r1;
            break;
    }
    // Generate MRZ hash first
    const mrzHash = (0, hash_1.hash)(dgHashAlgo, (0, format_1.formatMrz)(mrz));
    // Generate random hashes for other DGs, passing mrzHash for DG1
    const dataGroupHashes = generateDataGroupHashes(mrzHash, (0, hash_1.getHashLen)(dgHashAlgo));
    const eContent = (0, format_1.formatAndConcatenateDataHashes)(dataGroupHashes, 63);
    const signedAttr = (0, format_2.generateSignedAttr)((0, hash_1.hash)(eContentHashAlgo, eContent));
    const hashAlgo = signatureType.split('_')[1];
    const signature = sign(privateKeyPem, dsc, hashAlgo, signedAttr);
    const signatureBytes = Array.from(signature, (byte) => (byte < 128 ? byte : byte - 256));
    return (0, passport_1.initPassportDataParsing)({
        dsc: dsc,
        mrz: mrz,
        dg2Hash: dataGroupHashes.find(([dgNum]) => dgNum === 2)?.[1] || [],
        eContent: eContent,
        signedAttr: signedAttr,
        encryptedDigest: signatureBytes,
        documentType: "mock_passport"
    });
}
function sign(privateKeyPem, dsc, hashAlgorithm, eContent) {
    const { signatureAlgorithm, publicKeyDetails } = (0, parseCertificateSimple_1.parseCertificateSimple)(dsc);
    if (signatureAlgorithm === 'rsapss') {
        const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);
        const md = forge.md[hashAlgorithm].create();
        md.update(forge.util.binary.raw.encode(new Uint8Array(eContent)));
        const pss = forge.pss.create({
            md: forge.md[hashAlgorithm].create(),
            mgf: forge.mgf.mgf1.create(forge.md[hashAlgorithm].create()),
            saltLength: parseInt(publicKeyDetails.saltLength),
        });
        const signatureBytes = privateKey.sign(md, pss);
        return Array.from(signatureBytes, (c) => c.charCodeAt(0));
    }
    else if (signatureAlgorithm === 'ecdsa') {
        const curve = publicKeyDetails.curve;
        let curveForElliptic = (0, curves_1.getCurveForElliptic)(curve);
        const ec = new elliptic_1.default.ec(curveForElliptic);
        const privateKeyDer = Buffer.from(privateKeyPem.replace(/-----BEGIN EC PRIVATE KEY-----|\n|-----END EC PRIVATE KEY-----/g, ''), 'base64');
        const asn1Data = asn1.fromBER(privateKeyDer);
        const privateKeyBuffer = asn1Data.result.valueBlock.value[1].valueBlock.valueHexView;
        const keyPair = ec.keyFromPrivate(privateKeyBuffer);
        const msgHash = (0, hash_1.hash)(hashAlgorithm, eContent, 'hex');
        const signature = keyPair.sign(msgHash, 'hex');
        const signatureBytes = Array.from(Buffer.from(signature.toDER(), 'hex'));
        return signatureBytes;
    }
    else {
        const privKey = forge.pki.privateKeyFromPem(privateKeyPem);
        const md = forge.md[hashAlgorithm].create();
        md.update(forge.util.binary.raw.encode(new Uint8Array(eContent)));
        const forgeSignature = privKey.sign(md);
        return Array.from(forgeSignature, (c) => c.charCodeAt(0));
    }
}
