"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatEndpoint = formatEndpoint;
exports.hashEndpointWithScope = hashEndpointWithScope;
exports.stringToBigInt = stringToBigInt;
exports.bigIntToString = bigIntToString;
const poseidon_lite_1 = require("poseidon-lite");
const hash_1 = require("./hash");
function formatEndpoint(endpoint) {
    if (!endpoint)
        return '';
    return endpoint
        .replace(/^https?:\/\//, '')
        .split('/')[0];
}
function hashEndpointWithScope(endpoint, scope) {
    const formattedEndpoint = formatEndpoint(endpoint);
    const endpointChunks = [];
    let remaining = formattedEndpoint;
    while (remaining.length > 0) {
        const chunk = remaining.slice(0, 31);
        endpointChunks.push(chunk);
        remaining = remaining.slice(31);
    }
    if (endpointChunks.length > 16) {
        throw new Error("Endpoint must be less than 496 characters");
    }
    const chunkedEndpointBigInts = endpointChunks.map(stringToBigInt);
    const endpointHash = (0, hash_1.flexiblePoseidon)(chunkedEndpointBigInts);
    const scopeBigInt = stringToBigInt(scope);
    return (0, poseidon_lite_1.poseidon2)([endpointHash, scopeBigInt]).toString();
}
function stringToBigInt(str) {
    // Validate input contains only ASCII characters
    if (!/^[\x00-\x7F]*$/.test(str)) {
        throw new Error("Input must contain only ASCII characters (0-127)");
    }
    let result = 0n;
    for (let i = 0; i < str.length; i++) {
        result = (result << 8n) | BigInt(str.charCodeAt(i));
    }
    // Check size limit
    const MAX_VALUE = (1n << 248n) - 1n;
    if (result > MAX_VALUE) {
        console.log(`str: ${str}, str.length: ${str.length}`);
        throw new Error("Resulting BigInt exceeds maximum size of 31 bytes");
    }
    return result;
}
function bigIntToString(bigInt) {
    if (bigInt === 0n)
        return '';
    let result = '';
    let tempBigInt = bigInt;
    while (tempBigInt > 0n) {
        const charCode = Number(tempBigInt & 0xffn);
        result = String.fromCharCode(charCode) + result;
        tempBigInt = tempBigInt >> 8n;
    }
    return result;
}
