"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.flexiblePoseidon = flexiblePoseidon;
exports.hash = hash;
exports.getHashLen = getHashLen;
exports.customHasher = customHasher;
exports.packBytesAndPoseidon = packBytesAndPoseidon;
const poseidon_lite_1 = require("poseidon-lite");
const js_sha256_1 = require("js-sha256");
const js_sha1_1 = require("js-sha1");
const js_sha512_1 = require("js-sha512");
const bytes_1 = require("./bytes");
const forge = __importStar(require("node-forge"));
function flexiblePoseidon(inputs) {
    switch (inputs.length) {
        case 1:
            return (0, poseidon_lite_1.poseidon1)(inputs);
        case 2:
            return (0, poseidon_lite_1.poseidon2)(inputs);
        case 3:
            return (0, poseidon_lite_1.poseidon3)(inputs);
        case 4:
            return (0, poseidon_lite_1.poseidon4)(inputs);
        case 5:
            return (0, poseidon_lite_1.poseidon5)(inputs);
        case 6:
            return (0, poseidon_lite_1.poseidon6)(inputs);
        case 7:
            return (0, poseidon_lite_1.poseidon7)(inputs);
        case 8:
            return (0, poseidon_lite_1.poseidon8)(inputs);
        case 9:
            return (0, poseidon_lite_1.poseidon9)(inputs);
        case 10:
            return (0, poseidon_lite_1.poseidon10)(inputs);
        case 11:
            return (0, poseidon_lite_1.poseidon11)(inputs);
        case 12:
            return (0, poseidon_lite_1.poseidon12)(inputs);
        case 13:
            return (0, poseidon_lite_1.poseidon13)(inputs);
        case 14:
            return (0, poseidon_lite_1.poseidon14)(inputs);
        case 15:
            return (0, poseidon_lite_1.poseidon15)(inputs);
        case 16:
            return (0, poseidon_lite_1.poseidon16)(inputs);
        default:
            throw new Error(`Unsupported number of inputs: ${inputs.length}`);
    }
}
// hash function - crypto is not supported in react native
function hash(hashFunction, bytesArray, format = 'bytes') {
    const unsignedBytesArray = bytesArray.map((byte) => byte & 0xff);
    let hashResult;
    switch (hashFunction) {
        case 'sha1':
            hashResult = (0, js_sha1_1.sha1)(unsignedBytesArray);
            break;
        case 'sha224':
            hashResult = (0, js_sha256_1.sha224)(unsignedBytesArray);
            break;
        case 'sha256':
            hashResult = (0, js_sha256_1.sha256)(unsignedBytesArray);
            break;
        case 'sha384':
            hashResult = (0, js_sha512_1.sha384)(unsignedBytesArray);
            break;
        case 'sha512':
            hashResult = (0, js_sha512_1.sha512)(unsignedBytesArray);
            break;
        default:
            console.log('\x1b[31m%s\x1b[0m', `${hashFunction} not found in hash`); // Log in red
            hashResult = (0, js_sha256_1.sha256)(unsignedBytesArray); // Default to sha256
    }
    if (format === 'hex') {
        return hashResult;
    }
    if (format === 'bytes') {
        return (0, bytes_1.hexToSignedBytes)(hashResult);
    }
    if (format === 'binary') {
        return forge.util.binary.raw.encode(new Uint8Array((0, bytes_1.hexToSignedBytes)(hashResult)));
    }
    throw new Error(`Invalid format: ${format}`);
}
function getHashLen(hashFunction) {
    switch (hashFunction) {
        case 'sha1':
            return 20;
        case 'sha224':
            return 28;
        case 'sha256':
            return 32;
        case 'sha384':
            return 48;
        case 'sha512':
            return 64;
        default:
            console.log(`${hashFunction} not found in getHashLen`);
            return 32;
    }
}
function customHasher(pubKeyFormatted) {
    if (pubKeyFormatted.length < 16) {
        // if k is less than 16, we can use a single poseidon hash
        return flexiblePoseidon(pubKeyFormatted.map(BigInt)).toString();
    }
    else {
        const rounds = Math.ceil(pubKeyFormatted.length / 16); // do up to 16 rounds of poseidon
        if (rounds > 16) {
            throw new Error('Number of rounds is greater than 16');
        }
        const hash = new Array(rounds);
        for (let i = 0; i < rounds; i++) {
            hash[i] = { inputs: new Array(16).fill(BigInt(0)) };
        }
        for (let i = 0; i < rounds; i++) {
            for (let j = 0; j < 16; j++) {
                if (i * 16 + j < pubKeyFormatted.length) {
                    hash[i].inputs[j] = BigInt(pubKeyFormatted[i * 16 + j]);
                }
            }
        }
        const finalHash = flexiblePoseidon(hash.map((h) => (0, poseidon_lite_1.poseidon16)(h.inputs)));
        return finalHash.toString();
    }
}
function packBytesAndPoseidon(unpacked) {
    const packed = (0, bytes_1.packBytesArray)(unpacked);
    return customHasher(packed.map(String)).toString();
}
