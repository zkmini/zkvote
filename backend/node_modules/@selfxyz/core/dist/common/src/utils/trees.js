"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCSCATree = getCSCATree;
exports.getDSCTree = getDSCTree;
exports.getCommitmentTree = getCommitmentTree;
exports.fetchTreeFromUrl = fetchTreeFromUrl;
exports.getLeaf = getLeaf;
exports.getLeafDscTreeFromDscCertificateMetadata = getLeafDscTreeFromDscCertificateMetadata;
exports.getLeafDscTreeFromParsedDsc = getLeafDscTreeFromParsedDsc;
exports.getLeafDscTree = getLeafDscTree;
exports.getLeafCscaTree = getLeafCscaTree;
exports.getDscTreeInclusionProof = getDscTreeInclusionProof;
exports.getCscaTreeInclusionProof = getCscaTreeInclusionProof;
exports.getCscaTreeRoot = getCscaTreeRoot;
exports.formatRoot = formatRoot;
exports.generateSMTProof = generateSMTProof;
exports.generateMerkleProof = generateMerkleProof;
exports.buildSMT = buildSMT;
exports.getCountryLeaf = getCountryLeaf;
exports.getPassportNumberAndNationalityLeaf = getPassportNumberAndNationalityLeaf;
exports.getNameDobLeaf = getNameDobLeaf;
exports.getNameYobLeaf = getNameYobLeaf;
exports.getNameLeaf = getNameLeaf;
exports.getDobLeaf = getDobLeaf;
const poseidon_lite_1 = require("poseidon-lite");
const zk_kit_smt_1 = require("@openpassport/zk-kit-smt");
const uuid_1 = require("./circuits/uuid");
const zk_kit_lean_imt_1 = require("@openpassport/zk-kit-lean-imt");
const hash_1 = require("./hash");
const parseDscCertificateData_1 = require("./passports/passport_parsing/parseDscCertificateData");
const parseCertificateSimple_1 = require("./certificate_parsing/parseCertificateSimple");
const constants_1 = require("../constants/constants");
const constants_2 = require("../constants/constants");
const constants_3 = require("../constants/constants");
const zk_kit_imt_1 = require("@openpassport/zk-kit-imt");
const passport_1 = require("./passports/passport");
const i18n_iso_countries_1 = __importDefault(require("i18n-iso-countries"));
const en_json_1 = __importDefault(require("i18n-iso-countries/langs/en.json"));
i18n_iso_countries_1.default.registerLocale(en_json_1.default);
async function getCSCATree(endpointType) {
    const cscaTreeUrl = (endpointType === 'celo' || endpointType === 'https') ? constants_2.CSCA_TREE_URL : constants_1.CSCA_TREE_URL_STAGING;
    const response = await fetch(cscaTreeUrl);
    const data = await response.json();
    const status = data.status ? data.status : data;
    if (status === 'error') {
        throw new Error('Error fetching CSCA tree');
    }
    const tree = data.data ? JSON.parse(data.data) : data;
    console.log('CSCA tree:', tree);
    return tree;
}
async function getDSCTree(endpointType) {
    const dscTreeUrl = (endpointType === 'celo' || endpointType === 'https') ? constants_2.DSC_TREE_URL : constants_1.DSC_TREE_URL_STAGING;
    const response = await fetch(dscTreeUrl);
    const data = await response.json();
    const status = data.status ? data.status : data;
    if (status === 'error') {
        throw new Error('Error fetching DSC tree');
    }
    const tree = data.data ? data.data : data;
    console.log('DSC tree:', tree);
    return tree;
}
async function getCommitmentTree(documentType) {
    const identityTreeUrl = !documentType || typeof documentType !== 'string' || documentType === 'passport' ? constants_1.IDENTITY_TREE_URL : constants_1.IDENTITY_TREE_URL_STAGING;
    const response = await fetch(identityTreeUrl);
    return await response.json().then(data => data.data ? data.data : data);
}
async function fetchTreeFromUrl(url) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    const commitmentMerkleTree = await response.json();
    console.log('\x1b[90m%s\x1b[0m', 'commitment merkle tree: ', commitmentMerkleTree);
    const tree = zk_kit_lean_imt_1.LeanIMT.import((a, b) => (0, poseidon_lite_1.poseidon2)([a, b]), commitmentMerkleTree);
    return tree;
}
/** get leaf for DSC and CSCA Trees */
function getLeaf(parsed, type) {
    if (type === 'dsc') {
        // for now, we pad it for sha
        const tbsArray = Object.keys(parsed.tbsBytes).map(key => parsed.tbsBytes[key]);
        const [paddedTbsBytes, tbsBytesPaddedLength] = (0, passport_1.pad)(parsed.hashAlgorithm)(tbsArray, constants_3.max_dsc_bytes);
        const dsc_hash = (0, hash_1.packBytesAndPoseidon)(Array.from(paddedTbsBytes));
        return (0, poseidon_lite_1.poseidon2)([dsc_hash, tbsArray.length]).toString();
    }
    else {
        const tbsBytesArray = Array.from(parsed.tbsBytes);
        const paddedTbsBytesArray = tbsBytesArray.concat(new Array(constants_1.max_csca_bytes - tbsBytesArray.length).fill(0));
        const csca_hash = (0, hash_1.packBytesAndPoseidon)(paddedTbsBytesArray);
        return (0, poseidon_lite_1.poseidon2)([csca_hash, tbsBytesArray.length]).toString();
    }
}
function getLeafDscTreeFromDscCertificateMetadata(dscParsed, dscMetaData) {
    const cscaParsed = (0, parseCertificateSimple_1.parseCertificateSimple)(dscMetaData.csca);
    return getLeafDscTree(dscParsed, cscaParsed);
}
function getLeafDscTreeFromParsedDsc(dscParsed) {
    return getLeafDscTreeFromDscCertificateMetadata(dscParsed, (0, parseDscCertificateData_1.parseDscCertificateData)(dscParsed));
}
function getLeafDscTree(dsc_parsed, csca_parsed) {
    const dscLeaf = getLeaf(dsc_parsed, 'dsc');
    const cscaLeaf = getLeaf(csca_parsed, 'csca');
    return (0, poseidon_lite_1.poseidon2)([dscLeaf, cscaLeaf]).toString();
}
function getLeafCscaTree(csca_parsed) {
    return getLeaf(csca_parsed, 'csca');
}
function getDscTreeInclusionProof(leaf, serialized_dsc_tree) {
    const hashFunction = (a, b) => (0, poseidon_lite_1.poseidon2)([a, b]);
    const tree = zk_kit_lean_imt_1.LeanIMT.import(hashFunction, serialized_dsc_tree);
    const index = tree.indexOf(BigInt(leaf));
    if (index === -1) {
        throw new Error('Your public key was not found in the registry');
    }
    const { siblings, path, leaf_depth } = generateMerkleProof(tree, index, constants_1.DSC_TREE_DEPTH);
    return [tree.root, path, siblings, leaf_depth];
}
function getCscaTreeInclusionProof(leaf, _serialized_csca_tree) {
    let tree = new zk_kit_imt_1.IMT(poseidon_lite_1.poseidon2, constants_1.CSCA_TREE_DEPTH, 0, 2);
    tree.setNodes(_serialized_csca_tree);
    const index = tree.indexOf(leaf);
    if (index === -1) {
        throw new Error('Your public key was not found in the registry');
    }
    const proof = tree.createProof(index);
    return [tree.root, proof.pathIndices.map(index => index.toString()), proof.siblings.flat().map(sibling => sibling.toString())];
}
function getCscaTreeRoot(serialized_csca_tree) {
    let tree = new zk_kit_imt_1.IMT(poseidon_lite_1.poseidon2, constants_1.CSCA_TREE_DEPTH, 0, 2);
    tree.setNodes(serialized_csca_tree);
    return tree.root;
}
function formatRoot(root) {
    let rootHex = BigInt(root).toString(16);
    return rootHex.length % 2 === 0 ? '0x' + rootHex : '0x0' + rootHex;
}
function generateSMTProof(smt, leaf) {
    const { entry, matchingEntry, siblings, root, membership } = smt.createProof(leaf);
    const leaf_depth = siblings.length;
    let closestleaf;
    if (!matchingEntry) {
        // we got the 0 leaf or membership
        // then check if entry[1] exists
        if (!entry[1]) {
            // non membership proof
            closestleaf = BigInt(0); // 0 leaf
        }
        else {
            closestleaf = BigInt(entry[0]); // leaf itself (memb proof)
        }
    }
    else {
        // non membership proof
        closestleaf = BigInt(matchingEntry[0]); // actual closest
    }
    // PATH, SIBLINGS manipulation as per binary tree in the circuit
    siblings.reverse();
    while (siblings.length < constants_1.OFAC_TREE_LEVELS)
        siblings.push(BigInt(0));
    // ----- Useful for debugging hence leaving as comments -----
    // const binary = entry[0].toString(2)
    // const bits = binary.slice(-leaf_depth);
    // let indices = bits.padEnd(256, "0").split("").map(Number)
    // const pathToMatch = num2Bits(256,BigInt(entry[0]))
    // while(indices.length < 256) indices.push(0);
    // // CALCULATED ROOT FOR TESTING
    // // closestleaf, leaf_depth, siblings, indices, root : needed
    // let calculatedNode = poseidon3([closestleaf,1,1]);
    // console.log("Initial node while calculating",calculatedNode)
    // console.log(smt.verifyProof(smt.createProof(leaf)))
    // for (let i= 0; i < leaf_depth ; i++) {
    //   const childNodes: any = indices[i] ? [siblings[i], calculatedNode] : [calculatedNode, siblings[i]]
    //   console.log(indices[i],childNodes)
    //   calculatedNode = poseidon2(childNodes)
    // }
    // console.log("Actual node", root)
    // console.log("calculated node", calculatedNode)
    // -----------------------------------------------------------
    return {
        root,
        leaf_depth,
        closestleaf,
        siblings,
    };
}
function generateMerkleProof(imt, _index, maxleaf_depth) {
    const { siblings: siblings, index } = imt.generateProof(_index);
    const leaf_depth = siblings.length;
    // The index must be converted to a list of indices, 1 for each tree level.
    // The circuit tree leaf_depth is 20, so the number of siblings must be 20, even if
    // the tree leaf_depth is actually 3. The missing siblings can be set to 0, as they
    // won't be used to calculate the root in the circuit.
    const path = [];
    for (let i = 0; i < maxleaf_depth; i += 1) {
        path.push((index >> i) & 1);
        if (siblings[i] === undefined) {
            siblings[i] = BigInt(0);
        }
    }
    return { siblings, path, leaf_depth };
}
// SMT trees for 3 levels of matching :
// 1. Passport Number and Nationality tree : level 3 (Absolute Match)
// 2. Name and date of birth combo tree : level 2 (High Probability Match)
// 3. Name and year of birth combo tree : level 1 (Partial Match)
function buildSMT(field, treetype) {
    let count = 0;
    let startTime = performance.now();
    const hash2 = (childNodes) => childNodes.length === 2 ? (0, poseidon_lite_1.poseidon2)(childNodes) : (0, poseidon_lite_1.poseidon3)(childNodes);
    const tree = new zk_kit_smt_1.SMT(hash2, true);
    for (let i = 0; i < field.length; i++) {
        const entry = field[i];
        if (i !== 0) {
            console.log('Processing', treetype, 'number', i, 'out of', field.length);
        }
        let leaf = BigInt(0);
        if (treetype == 'passport_no_and_nationality') {
            leaf = processPassportNoAndNationality(entry.Pass_No, entry.Pass_Country, i);
        }
        else if (treetype == 'name_and_dob') {
            leaf = processNameAndDob(entry, i);
        }
        else if (treetype == 'name_and_yob') {
            leaf = processNameAndYob(entry, i);
        }
        else if (treetype == 'country') {
            const keys = Object.keys(entry);
            leaf = processCountry(keys[0], entry[keys[0]], i);
        }
        if (leaf == BigInt(0) || tree.createProof(leaf).membership) {
            console.log('This entry already exists in the tree, skipping...');
            continue;
        }
        count += 1;
        tree.add(leaf, BigInt(1));
    }
    console.log('Total', treetype, 'paresed are : ', count, ' over ', field.length);
    console.log(treetype, 'tree built in', performance.now() - startTime, 'ms');
    return [count, performance.now() - startTime, tree];
}
function processPassportNoAndNationality(passno, nationality, index) {
    if (passno.length > 9) {
        console.log('passport number length is greater than 9:', index, passno);
    }
    else if (passno.length < 9) {
        while (passno.length != 9) {
            passno += '<';
        }
    }
    const countryCode = getCountryCode(nationality);
    if (!countryCode) {
        console.log('Error getting country code', index, nationality);
        return BigInt(0);
    }
    console.log('nationality and countryCode', nationality, countryCode);
    const leaf = getPassportNumberAndNationalityLeaf((0, uuid_1.stringToAsciiBigIntArray)(passno), (0, uuid_1.stringToAsciiBigIntArray)(countryCode), index);
    if (!leaf) {
        console.log('Error creating leaf value', index, passno, nationality);
        return BigInt(0);
    }
    return leaf;
}
// this is a temporary workaround for some of the country name,
// will be removed once we parse the OFAC list better, starting from the XML file.
const normalizeCountryName = (country) => {
    const mapping = {
        "palestinian": "Palestine",
        "korea, north": "North Korea",
        "korea, south": "Korea, Republic of",
        "united kingdom": "United Kingdom",
        "syria": "Syrian Arab Republic",
        "burma": "Myanmar",
        "cabo verde": "Cape Verde",
        "congo, democratic republic of the": "Democratic Republic of the Congo",
        "macau": "Macao",
    };
    return mapping[country.toLowerCase()] || country;
};
const getCountryCode = (countryName) => {
    return i18n_iso_countries_1.default.getAlpha3Code(normalizeCountryName(countryName), "en");
};
function generateSmallKey(input) {
    return input % (BigInt(1) << BigInt(constants_1.OFAC_TREE_LEVELS));
}
function processNameAndDob(entry, i) {
    const firstName = entry.First_Name;
    const lastName = entry.Last_Name;
    const day = entry.day;
    const month = entry.month;
    const year = entry.year;
    if (day == null || month == null || year == null) {
        console.log('dob is null', i, entry);
        return BigInt(0);
    }
    const nameHash = processName(firstName, lastName, i);
    const dobHash = processDob(day, month, year, i);
    return generateSmallKey((0, poseidon_lite_1.poseidon2)([dobHash, nameHash]));
}
function processNameAndYob(entry, i) {
    const firstName = entry.First_Name;
    const lastName = entry.Last_Name;
    const year = entry.year;
    if (year == null) {
        console.log('year is null', i, entry);
        return BigInt(0);
    }
    const nameHash = processName(firstName, lastName, i);
    const yearHash = processYear(year, i);
    return generateSmallKey((0, poseidon_lite_1.poseidon2)([yearHash, nameHash]));
}
function processYear(year, i) {
    year = year.slice(-2);
    const yearArr = (0, uuid_1.stringToAsciiBigIntArray)(year);
    return getYearLeaf(yearArr);
}
function getYearLeaf(yearArr) {
    return (0, poseidon_lite_1.poseidon2)(yearArr);
}
function processName(firstName, lastName, i) {
    // LASTNAME<<FIRSTNAME<MIDDLENAME<<<... (6-44)
    firstName = firstName.replace(/'/g, '');
    firstName = firstName.replace(/\./g, '');
    firstName = firstName.replace(/[- ]/g, '<');
    lastName = lastName.replace(/'/g, '');
    lastName = lastName.replace(/[- ]/g, '<');
    lastName = lastName.replace(/\./g, '');
    // Removed apostrophes from the first name, eg O'Neil -> ONeil
    // Replace spaces and hyphens with '<' in the first name, eg John Doe -> John<Doe
    // TODO : Handle special cases like malaysia : no two filler characters like << for surname and givenname
    // TODO : Verify rules for . in names. eg : J. Doe (Done same as apostrophe for now)
    let arr = lastName + '<<' + firstName;
    if (arr.length > 39) {
        arr = arr.substring(0, 39);
    }
    else {
        while (arr.length < 39) {
            arr += '<';
        }
    }
    let nameArr = (0, uuid_1.stringToAsciiBigIntArray)(arr);
    return getNameLeaf(nameArr, i);
}
function processDob(day, month, year, i) {
    // YYMMDD
    const monthMap = {
        jan: '01',
        feb: '02',
        mar: '03',
        apr: '04',
        may: '05',
        jun: '06',
        jul: '07',
        aug: '08',
        sep: '09',
        oct: '10',
        nov: '11',
        dec: '12',
    };
    month = monthMap[month.toLowerCase()];
    year = year.slice(-2);
    const dob = year + month + day;
    let arr = (0, uuid_1.stringToAsciiBigIntArray)(dob);
    return getDobLeaf(arr, i);
}
function processCountry(country1, country2, i) {
    let arr = (0, uuid_1.stringToAsciiBigIntArray)(country1);
    let arr2 = (0, uuid_1.stringToAsciiBigIntArray)(country2);
    const leaf = getCountryLeaf(arr, arr2, i);
    if (!leaf) {
        console.log('Error creating leaf value', i, country1, country2);
        return BigInt(0);
    }
    return leaf;
}
function getCountryLeaf(country_by, country_to, i) {
    if (country_by.length !== 3 || country_to.length !== 3) {
        console.log('parsed passport length is not 3:', i, country_to, country_by);
        return;
    }
    try {
        const country = country_by.concat(country_to);
        return (0, poseidon_lite_1.poseidon6)(country);
    }
    catch (err) {
        console.log('err : sanc_country hash', err, i, country_by, country_to);
    }
}
function getPassportNumberAndNationalityLeaf(passport, nationality, i) {
    if (passport.length !== 9) {
        console.log('parsed passport length is not 9:', i, passport);
        return;
    }
    if (nationality.length !== 3) {
        console.log('parsed nationality length is not 3:', i, nationality);
        return;
    }
    try {
        const fullHash = (0, poseidon_lite_1.poseidon12)(passport.concat(nationality));
        return generateSmallKey(fullHash);
    }
    catch (err) {
        console.log('err : passport', err, i, passport);
    }
}
function getNameDobLeaf(nameMrz, dobMrz, i) {
    return generateSmallKey((0, poseidon_lite_1.poseidon2)([getDobLeaf(dobMrz), getNameLeaf(nameMrz)]));
}
function getNameYobLeaf(nameMrz, yobMrz, i) {
    return generateSmallKey((0, poseidon_lite_1.poseidon2)([getYearLeaf(yobMrz), getNameLeaf(nameMrz)]));
}
function getNameLeaf(nameMrz, i) {
    let middleChunks = [];
    let chunks = [];
    chunks.push(nameMrz.slice(0, 13), nameMrz.slice(13, 26), nameMrz.slice(26, 39)); // 39/3 for posedion to digest
    for (const chunk of chunks) {
        middleChunks.push((0, poseidon_lite_1.poseidon13)(chunk));
    }
    try {
        return (0, poseidon_lite_1.poseidon3)(middleChunks);
    }
    catch (err) {
        console.log('err : Name', err, i, nameMrz);
    }
}
function getDobLeaf(dobMrz, i) {
    if (dobMrz.length !== 6) {
        console.log('parsed dob length is not 9:', i, dobMrz);
        return;
    }
    try {
        return (0, poseidon_lite_1.poseidon6)(dobMrz);
    }
    catch (err) {
        console.log('err : Dob', err, i, dobMrz);
    }
}
