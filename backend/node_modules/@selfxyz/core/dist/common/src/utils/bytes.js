"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBinaryString = void 0;
exports.packBytes = packBytes;
exports.computeIntChunkLength = computeIntChunkLength;
exports.packBytesArray = packBytesArray;
exports.toUnsigned = toUnsigned;
exports.toSigned = toSigned;
exports.splitToWords = splitToWords;
exports.bytesToBigDecimal = bytesToBigDecimal;
exports.hexToDecimal = hexToDecimal;
exports.hexToSignedBytes = hexToSignedBytes;
exports.toUnsignedByte = toUnsignedByte;
exports.bigIntToChunkedBytes = bigIntToChunkedBytes;
exports.hexStringToSignedIntArray = hexStringToSignedIntArray;
exports.hexToBin = hexToBin;
exports.num2Bits = num2Bits;
exports.derToBytes = derToBytes;
const constants_1 = require("../constants/constants");
function packBytes(unpacked) {
    const bytesCount = [31, 31, 31];
    let packed = [0n, 0n, 0n];
    let byteIndex = 0;
    for (let i = 0; i < bytesCount.length; i++) {
        for (let j = 0; j < bytesCount[i]; j++) {
            if (byteIndex < unpacked.length) {
                packed[i] |= BigInt(unpacked[byteIndex]) << (BigInt(j) * 8n);
            }
            byteIndex++;
        }
    }
    return packed;
}
function computeIntChunkLength(byteLength) {
    const packSize = constants_1.MAX_BYTES_IN_FIELD;
    const remain = byteLength % packSize;
    let numChunks = (byteLength - remain) / packSize;
    if (remain > 0) {
        numChunks += 1;
    }
    return numChunks;
}
function packBytesArray(unpacked) {
    const packSize = constants_1.MAX_BYTES_IN_FIELD;
    const maxBytes = unpacked.length;
    const maxInts = computeIntChunkLength(maxBytes);
    const out = new Array(maxInts).fill(0n);
    for (let i = 0; i < maxInts; i++) {
        let sum = 0n;
        for (let j = 0; j < packSize; j++) {
            const idx = packSize * i + j;
            // Copy previous value if out of bounds
            if (idx >= maxBytes) {
                continue;
            }
            // First item of chunk is byte itself
            else if (j === 0) {
                sum = BigInt(unpacked[idx]);
            }
            // Every other item is 256^j * byte
            else {
                sum += (1n << BigInt(8 * j)) * BigInt(unpacked[idx]);
            }
        }
        out[i] = sum;
    }
    return out;
}
function toUnsigned(byte) {
    return byte & 0xff;
}
function toSigned(byte) {
    return byte > 127 ? byte - 256 : byte;
}
const toBinaryString = (byte) => {
    const binary = (parseInt(byte, 10) & 0xff).toString(2).padStart(8, '0');
    return binary;
};
exports.toBinaryString = toBinaryString;
function splitToWords(number, wordsize, numberElement) {
    let t = number;
    const words = [];
    for (let i = 0; i < numberElement; ++i) {
        const baseTwo = BigInt(2);
        words.push(`${t % BigInt(Math.pow(Number(baseTwo), wordsize))}`);
        t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), wordsize)));
    }
    if (!(t == BigInt(0))) {
        throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;
    }
    return words;
}
function bytesToBigDecimal(arr) {
    let result = BigInt(0);
    for (let i = 0; i < arr.length; i++) {
        result = result * BigInt(256) + BigInt(arr[i] & 0xff);
    }
    return result.toString();
}
function hexToDecimal(hex) {
    return BigInt(`0x${hex}`).toString();
}
function hexToSignedBytes(hexString) {
    let bytes = [];
    for (let i = 0; i < hexString.length - 1; i += 2) {
        let byte = parseInt(hexString.substr(i, 2), 16);
        bytes.push(byte >= 128 ? byte - 256 : byte);
    }
    return bytes;
}
function toUnsignedByte(signedByte) {
    return signedByte < 0 ? signedByte + 256 : signedByte;
}
function bigIntToChunkedBytes(num, bytesPerChunk, numChunks) {
    const res = [];
    const bigintNum = typeof num == 'bigint' ? num : num.valueOf();
    const msk = (1n << BigInt(bytesPerChunk)) - 1n;
    for (let i = 0; i < numChunks; ++i) {
        res.push(((bigintNum >> BigInt(i * bytesPerChunk)) & msk).toString());
    }
    return res;
}
function hexStringToSignedIntArray(hexString) {
    let result = [];
    for (let i = 0; i < hexString.length; i += 2) {
        let byte = parseInt(hexString.substr(i, 2), 16);
        result.push(byte > 127 ? byte - 256 : byte);
    }
    return result;
}
function hexToBin(n) {
    let bin = Number(`0x${n[0]}`).toString(2);
    for (let i = 1; i < n.length; i += 1) {
        bin += Number(`0x${n[i]}`).toString(2).padStart(4, '0');
    }
    return bin;
}
function num2Bits(n, inValue) {
    const out = new Array(n).fill(BigInt(0));
    let lc1 = BigInt(0);
    let e2 = BigInt(1);
    for (let i = 0; i < n; i++) {
        out[i] = (inValue >> BigInt(i)) & BigInt(1);
        if (out[i] !== BigInt(0) && out[i] !== BigInt(1)) {
            throw new Error('Bit value is not binary.');
        }
        lc1 += out[i] * e2;
        e2 = e2 << BigInt(1);
    }
    if (lc1 !== inValue) {
        throw new Error('Reconstructed value does not match the input.');
    }
    return out;
}
function derToBytes(derValue) {
    const bytes = [];
    for (let i = 0; i < derValue.length; i++) {
        bytes.push(derValue.charCodeAt(i));
    }
    return bytes;
}
