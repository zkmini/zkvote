"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCountryCodeFromMrz = getCountryCodeFromMrz;
exports.getCurveOrExponent = getCurveOrExponent;
exports.parsePassportData = parsePassportData;
const parseCertificateSimple_1 = require("../../certificate_parsing/parseCertificateSimple");
const constants_1 = require("../../../constants/constants");
const parseDscCertificateData_1 = require("./parseDscCertificateData");
const brutForcePassportSignature_1 = require("./brutForcePassportSignature");
const arrays_1 = require("../../arrays");
const format_1 = require("../format");
const hash_1 = require("../../hash");
const hash_2 = require("../../hash");
function findHashSizeOfEContent(eContent, signedAttr) {
    for (const hashFunction of constants_1.hashAlgos) {
        const hashValue = (0, hash_2.hash)(hashFunction, eContent);
        const hashOffset = (0, arrays_1.findSubarrayIndex)(signedAttr, hashValue);
        if (hashOffset !== -1) {
            return { hashFunction, offset: hashOffset };
        }
    }
    return { hashFunction: 'unknown', offset: -1 };
}
function findDG1HashInEContent(mrz, eContent) {
    const formattedMrz = (0, format_1.formatMrz)(mrz);
    for (const hashFunction of constants_1.hashAlgos) {
        const hashValue = (0, hash_2.hash)(hashFunction, formattedMrz);
        const normalizedHash = hashValue.map((byte) => (byte > 127 ? byte - 256 : byte));
        const hashOffset = (0, arrays_1.findSubarrayIndex)(eContent, normalizedHash);
        if (hashOffset !== -1) {
            return { hash: hashValue, hashFunction, offset: hashOffset };
        }
    }
    return null;
}
function getDgPaddingBytes(passportData, dg1HashFunction) {
    const formattedMrz = (0, format_1.formatMrz)(passportData.mrz);
    const hashValue = (0, hash_2.hash)(dg1HashFunction, formattedMrz);
    const normalizedHash = hashValue.map((byte) => (byte > 127 ? byte - 256 : byte));
    const dg1HashOffset = (0, arrays_1.findSubarrayIndex)(passportData.eContent, normalizedHash);
    const dg2Hash = passportData.dg2Hash;
    const normalizedDg2Hash = dg2Hash.map((byte) => (byte > 127 ? byte - 256 : byte));
    const dg2HashOffset = (0, arrays_1.findSubarrayIndex)(passportData.eContent, normalizedDg2Hash);
    return dg2HashOffset - dg1HashOffset - (0, hash_1.getHashLen)(dg1HashFunction);
}
function getCountryCodeFromMrz(mrz) {
    return mrz.substring(2, 5);
}
function getCurveOrExponent(certData) {
    if (certData.signatureAlgorithm === 'rsapss' || certData.signatureAlgorithm === 'rsa') {
        return certData.publicKeyDetails.exponent;
    }
    return certData.publicKeyDetails.curve;
}
function parsePassportData(passportData) {
    const dg1HashInfo = passportData.mrz
        ? findDG1HashInEContent(passportData.mrz, passportData.eContent)
        : null;
    const dg1HashFunction = dg1HashInfo?.hashFunction || 'unknown';
    const dg1HashOffset = dg1HashInfo?.offset || 0;
    let dgPaddingBytes = -1;
    try {
        dgPaddingBytes = getDgPaddingBytes(passportData, dg1HashFunction);
    }
    catch (error) {
        console.error('Error getting DG padding bytes:', error);
    }
    const { hashFunction: eContentHashFunction, offset: eContentHashOffset } = findHashSizeOfEContent(passportData.eContent, passportData.signedAttr);
    const brutForcedPublicKeyDetails = (0, brutForcePassportSignature_1.brutforceSignatureAlgorithm)(passportData);
    let parsedDsc = null;
    let dscSignatureAlgorithmBits = 0;
    let dscMetaData;
    if (passportData.dsc) {
        parsedDsc = (0, parseCertificateSimple_1.parseCertificateSimple)(passportData.dsc);
        dscSignatureAlgorithmBits = parseInt(parsedDsc.publicKeyDetails?.bits || '0');
        dscMetaData = (0, parseDscCertificateData_1.parseDscCertificateData)(parsedDsc);
    }
    return {
        dataGroups: passportData.dgPresents
            ?.toString()
            .split(',')
            .map((item) => item.replace('DG', ''))
            .join(',') || 'None',
        dg1Size: passportData.mrz ? passportData.mrz.length : 0,
        dg1HashSize: passportData.dg1Hash ? passportData.dg1Hash.length : 0,
        dg1HashFunction,
        dg1HashOffset,
        dgPaddingBytes,
        eContentSize: passportData.eContent?.length || 0,
        eContentHashFunction,
        eContentHashOffset,
        signedAttrSize: passportData.signedAttr?.length || 0,
        signedAttrHashFunction: brutForcedPublicKeyDetails.hashAlgorithm,
        signatureAlgorithm: brutForcedPublicKeyDetails.signatureAlgorithm,
        saltLength: brutForcedPublicKeyDetails.saltLength,
        curveOrExponent: parsedDsc ? getCurveOrExponent(parsedDsc) : 'unknown',
        signatureAlgorithmBits: dscSignatureAlgorithmBits,
        countryCode: passportData.mrz ? getCountryCodeFromMrz(passportData.mrz) : 'unknown',
        cscaFound: dscMetaData.cscaFound,
        cscaHashFunction: dscMetaData.cscaHashAlgorithm,
        cscaSignatureAlgorithm: dscMetaData.cscaSignatureAlgorithm,
        cscaSaltLength: dscMetaData.cscaSaltLength,
        cscaCurveOrExponent: dscMetaData.cscaCurveOrExponent,
        cscaSignatureAlgorithmBits: dscMetaData.cscaSignatureAlgorithmBits,
        dsc: passportData.dsc,
        csca: dscMetaData?.csca || '',
    };
}
