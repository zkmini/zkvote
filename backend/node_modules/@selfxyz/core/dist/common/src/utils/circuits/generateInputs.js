"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCircuitInputsDSC = generateCircuitInputsDSC;
exports.generateCircuitInputsRegister = generateCircuitInputsRegister;
exports.generateCircuitInputsVCandDisclose = generateCircuitInputsVCandDisclose;
exports.generateCircuitInputsOfac = generateCircuitInputsOfac;
exports.generateCircuitInputsCountryVerifier = generateCircuitInputsCountryVerifier;
exports.findIndexInTree = findIndexInTree;
exports.formatInput = formatInput;
const constants_1 = require("../../constants/constants");
const trees_1 = require("../trees");
const trees_2 = require("../trees");
const passport_1 = require("../passports/passport");
const hash_1 = require("../hash");
const format_1 = require("../passports/format");
const uuid_1 = require("./uuid");
const date_1 = require("../date");
const formatInputs_1 = require("./formatInputs");
const trees_3 = require("../trees");
const parseCertificateSimple_1 = require("../certificate_parsing/parseCertificateSimple");
const parseDscCertificateData_1 = require("../passports/passport_parsing/parseDscCertificateData");
function generateCircuitInputsDSC(dscCertificate, serializedCscaTree) {
    const dscParsed = (0, parseCertificateSimple_1.parseCertificateSimple)(dscCertificate);
    const dscMetadata = (0, parseDscCertificateData_1.parseDscCertificateData)(dscParsed);
    const cscaParsed = (0, parseCertificateSimple_1.parseCertificateSimple)(dscMetadata.csca);
    // CSCA is padded with 0s to max_csca_bytes
    const cscaTbsBytesPadded = (0, passport_1.padWithZeroes)(cscaParsed.tbsBytes, constants_1.max_csca_bytes);
    const dscTbsBytes = dscParsed.tbsBytes;
    // DSC is padded using sha padding because it will be hashed in the circuit
    const [dscTbsBytesPadded, dscTbsBytesLen] = (0, passport_1.pad)(dscMetadata.cscaHashAlgorithm)(dscTbsBytes, constants_1.max_dsc_bytes);
    const leaf = (0, trees_1.getLeafCscaTree)(cscaParsed);
    const [root, path, siblings] = (0, trees_2.getCscaTreeInclusionProof)(leaf, serializedCscaTree);
    // Parse CSCA certificate and get its public key
    const csca_pubKey_formatted = (0, passport_1.getCertificatePubKey)(cscaParsed, dscMetadata.cscaSignatureAlgorithm, dscMetadata.cscaHashAlgorithm);
    const signatureRaw = (0, passport_1.extractSignatureFromDSC)(dscCertificate);
    const signature = (0, passport_1.formatSignatureDSCCircuit)(dscMetadata.cscaSignatureAlgorithm, dscMetadata.cscaHashAlgorithm, cscaParsed, signatureRaw);
    // Get start index of CSCA pubkey based on algorithm
    const [startIndex, keyLength] = (0, passport_1.findStartPubKeyIndex)(cscaParsed, cscaTbsBytesPadded, dscMetadata.cscaSignatureAlgorithm);
    return {
        raw_csca: cscaTbsBytesPadded.map(x => x.toString()),
        raw_csca_actual_length: BigInt(cscaParsed.tbsBytes.length).toString(),
        csca_pubKey_offset: startIndex.toString(),
        csca_pubKey_actual_size: BigInt(keyLength).toString(),
        raw_dsc: Array.from(dscTbsBytesPadded).map(x => x.toString()),
        raw_dsc_padded_length: BigInt(dscTbsBytesLen).toString(), // with the sha padding actually
        csca_pubKey: csca_pubKey_formatted,
        signature,
        merkle_root: root,
        path: path,
        siblings: siblings,
    };
}
function generateCircuitInputsRegister(secret, passportData, serializedDscTree) {
    const { mrz, eContent, signedAttr } = passportData;
    const passportMetadata = passportData.passportMetadata;
    const dscParsed = passportData.dsc_parsed;
    const [dscTbsBytesPadded,] = (0, passport_1.pad)(dscParsed.hashAlgorithm)(dscParsed.tbsBytes, constants_1.max_dsc_bytes);
    const { pubKey, signature, signatureAlgorithmFullName } = (0, passport_1.getPassportSignatureInfos)(passportData);
    const mrz_formatted = (0, format_1.formatMrz)(mrz);
    if (eContent.length > constants_1.MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]) {
        console.error(`eContent too long (${eContent.length} bytes). Max length is ${constants_1.MAX_PADDED_ECONTENT_LEN[signatureAlgorithmFullName]} bytes.`);
        throw new Error(`This length of datagroups (${eContent.length} bytes) is currently unsupported. Please contact us so we add support!`);
    }
    const [eContentPadded, eContentLen] = (0, passport_1.pad)(passportMetadata.eContentHashFunction)(eContent, constants_1.MAX_PADDED_ECONTENT_LEN[passportMetadata.dg1HashFunction]);
    const [signedAttrPadded, signedAttrPaddedLen] = (0, passport_1.pad)(passportMetadata.signedAttrHashFunction)(signedAttr, constants_1.MAX_PADDED_SIGNED_ATTR_LEN[passportMetadata.eContentHashFunction]);
    const dsc_leaf = (0, trees_1.getLeafDscTree)(dscParsed, passportData.csca_parsed); // TODO: WRONG 
    const [root, path, siblings, leaf_depth] = (0, trees_2.getDscTreeInclusionProof)(dsc_leaf, serializedDscTree);
    const csca_tree_leaf = (0, trees_1.getLeafCscaTree)(passportData.csca_parsed);
    // Get start index of DSC pubkey based on algorithm
    const [startIndex, keyLength] = (0, passport_1.findStartPubKeyIndex)(dscParsed, dscTbsBytesPadded, dscParsed.signatureAlgorithm);
    const inputs = {
        raw_dsc: dscTbsBytesPadded.map(x => x.toString()),
        raw_dsc_actual_length: [BigInt(dscParsed.tbsBytes.length).toString()],
        dsc_pubKey_offset: startIndex,
        dsc_pubKey_actual_size: [BigInt(keyLength).toString()],
        dg1: mrz_formatted,
        dg1_hash_offset: passportMetadata.dg1HashOffset,
        eContent: eContentPadded,
        eContent_padded_length: eContentLen,
        signed_attr: signedAttrPadded,
        signed_attr_padded_length: signedAttrPaddedLen,
        signed_attr_econtent_hash_offset: passportMetadata.eContentHashOffset,
        pubKey_dsc: pubKey,
        signature_passport: signature,
        merkle_root: [BigInt(root).toString()],
        leaf_depth: leaf_depth,
        path: path,
        siblings: siblings,
        csca_tree_leaf: csca_tree_leaf,
        secret: secret,
    };
    return Object.entries(inputs)
        .map(([key, value]) => ({
        [key]: formatInput(value),
    }))
        .reduce((acc, curr) => ({ ...acc, ...curr }), {});
}
function generateCircuitInputsVCandDisclose(secret, attestation_id, passportData, scope, selector_dg1, selector_older_than, merkletree, majority, passportNo_smt, nameAndDob_smt, nameAndYob_smt, selector_ofac, forbidden_countries_list, user_identifier) {
    const formattedMrz = (0, format_1.formatMrz)(passportData.mrz);
    const passportMetadata = passportData.passportMetadata;
    const eContent_shaBytes = (0, hash_1.hash)(passportMetadata.eContentHashFunction, Array.from(passportData.eContent), 'bytes');
    const eContent_packed_hash = (0, hash_1.packBytesAndPoseidon)(eContent_shaBytes.map((byte) => byte & 0xff));
    const dsc_tree_leaf = (0, trees_1.getLeafDscTree)(passportData.dsc_parsed, passportData.csca_parsed);
    const commitment = (0, passport_1.generateCommitment)(secret, attestation_id, passportData);
    const index = findIndexInTree(merkletree, BigInt(commitment));
    const { siblings, path, leaf_depth } = (0, trees_3.generateMerkleProof)(merkletree, index, constants_1.COMMITMENT_TREE_DEPTH);
    const formattedMajority = majority.length === 1 ? `0${majority}` : majority;
    const majority_ascii = formattedMajority.split('').map((char) => char.charCodeAt(0));
    // SMT - OFAC
    const passportNo_leaf = (0, trees_1.getPassportNumberAndNationalityLeaf)(formattedMrz.slice(49, 58), formattedMrz.slice(59, 62));
    const namedob_leaf = (0, trees_1.getNameDobLeaf)(formattedMrz.slice(10, 49), formattedMrz.slice(62, 68));
    const name_leaf = (0, trees_1.getNameYobLeaf)(formattedMrz.slice(10, 49), formattedMrz.slice(62, 64));
    const { root: passportNo_smt_root, closestleaf: passportNo_smt_leaf_key, siblings: passportNo_smt_siblings, } = (0, trees_3.generateSMTProof)(passportNo_smt, passportNo_leaf);
    const { root: nameAndDob_smt_root, closestleaf: nameAndDob_smt_leaf_key, siblings: nameAndDob_smt_siblings, } = (0, trees_3.generateSMTProof)(nameAndDob_smt, namedob_leaf);
    const { root: nameAndYob_smt_root, closestleaf: nameAndYob_smt_leaf_key, siblings: nameAndYob_smt_siblings, } = (0, trees_3.generateSMTProof)(nameAndYob_smt, name_leaf);
    return {
        secret: formatInput(secret),
        attestation_id: formatInput(attestation_id),
        dg1: formatInput(formattedMrz),
        eContent_shaBytes_packed_hash: formatInput(eContent_packed_hash),
        dsc_tree_leaf: formatInput(dsc_tree_leaf),
        merkle_root: formatInput(merkletree.root),
        leaf_depth: formatInput(leaf_depth),
        path: formatInput(path),
        siblings: formatInput(siblings),
        selector_dg1: formatInput(selector_dg1),
        selector_older_than: formatInput(selector_older_than),
        scope: formatInput(scope),
        current_date: formatInput((0, date_1.getCurrentDateYYMMDD)()),
        majority: formatInput(majority_ascii),
        user_identifier: formatInput((0, uuid_1.castFromUUID)(user_identifier)),
        ofac_passportno_smt_root: formatInput(passportNo_smt_root),
        ofac_passportno_smt_leaf_key: formatInput(passportNo_smt_leaf_key),
        ofac_passportno_smt_siblings: formatInput(passportNo_smt_siblings),
        ofac_namedob_smt_root: formatInput(nameAndDob_smt_root),
        ofac_namedob_smt_leaf_key: formatInput(nameAndDob_smt_leaf_key),
        ofac_namedob_smt_siblings: formatInput(nameAndDob_smt_siblings),
        ofac_nameyob_smt_root: formatInput(nameAndYob_smt_root),
        ofac_nameyob_smt_leaf_key: formatInput(nameAndYob_smt_leaf_key),
        ofac_nameyob_smt_siblings: formatInput(nameAndYob_smt_siblings),
        selector_ofac: formatInput(selector_ofac),
        forbidden_countries_list: formatInput((0, formatInputs_1.formatCountriesList)(forbidden_countries_list)),
    };
}
function generateCircuitInputsOfac(passportData, sparsemerkletree, proofLevel) {
    const mrz_bytes = (0, format_1.formatMrz)(passportData.mrz);
    console.log('mrz_bytes', mrz_bytes);
    console.log('mrz_bytes.slice(59, 62)', mrz_bytes.slice(59, 62).map((byte) => String.fromCharCode(byte)));
    const passport_leaf = (0, trees_1.getPassportNumberAndNationalityLeaf)(mrz_bytes.slice(49, 58), mrz_bytes.slice(59, 62));
    const namedob_leaf = (0, trees_1.getNameDobLeaf)(mrz_bytes.slice(10, 49), mrz_bytes.slice(62, 68)); // [57-62] + 5 shift
    const name_leaf = (0, trees_1.getNameYobLeaf)(mrz_bytes.slice(10, 49), mrz_bytes.slice(62, 64));
    let root, closestleaf, siblings;
    if (proofLevel == 3) {
        ({ root, closestleaf, siblings } = (0, trees_3.generateSMTProof)(sparsemerkletree, passport_leaf));
    }
    else if (proofLevel == 2) {
        ({ root, closestleaf, siblings } = (0, trees_3.generateSMTProof)(sparsemerkletree, namedob_leaf));
    }
    else if (proofLevel == 1) {
        ({ root, closestleaf, siblings } = (0, trees_3.generateSMTProof)(sparsemerkletree, name_leaf));
    }
    else {
        throw new Error('Invalid proof level');
    }
    return {
        dg1: formatInput(mrz_bytes),
        smt_leaf_key: formatInput(closestleaf),
        smt_root: formatInput(root),
        smt_siblings: formatInput(siblings),
    };
}
function generateCircuitInputsCountryVerifier(passportData, sparsemerkletree) {
    const mrz_bytes = (0, format_1.formatMrz)(passportData.mrz);
    const usa_ascii = (0, uuid_1.stringToAsciiBigIntArray)('USA');
    const country_leaf = (0, trees_1.getCountryLeaf)(usa_ascii, mrz_bytes.slice(7, 10));
    const { root, closestleaf, siblings } = (0, trees_3.generateSMTProof)(sparsemerkletree, country_leaf);
    return {
        dg1: formatInput(mrz_bytes),
        hostCountry: formatInput(usa_ascii),
        smt_leaf_key: formatInput(closestleaf),
        smt_root: formatInput(root),
        smt_siblings: formatInput(siblings),
    };
}
// this get the commitment index whether it is a string or a bigint
// this is necessary rn because when the tree is send from the server in a serialized form,
// the bigints are converted to strings and I can't figure out how to use tree.import to load bigints there
function findIndexInTree(tree, commitment) {
    let index = tree.indexOf(commitment);
    if (index === -1) {
        index = tree.indexOf(commitment.toString());
    }
    if (index === -1) {
        throw new Error('This commitment was not found in the tree');
    }
    else {
        //  console.log(`Index of commitment in the registry: ${index}`);
    }
    return index;
}
function formatInput(input) {
    if (Array.isArray(input)) {
        return input.map((item) => BigInt(item).toString());
    }
    else if (input instanceof Uint8Array) {
        return Array.from(input).map((num) => BigInt(num).toString());
    }
    else if (typeof input === 'string' && input.includes(',')) {
        const numbers = input
            .split(',')
            .map((s) => s.trim())
            .filter((s) => s !== '' && !isNaN(Number(s)))
            .map(Number);
        try {
            return numbers.map((num) => BigInt(num).toString());
        }
        catch (e) {
            throw e;
        }
    }
    else {
        return [BigInt(input).toString()];
    }
}
