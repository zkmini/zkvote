"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelfBackendVerifier = void 0;
const IdentityRegistryImplV1_1 = require("./abi/IdentityRegistryImplV1");
const VerifyAll_1 = require("./abi/VerifyAll");
const contractAddresses_1 = require("./constants/contractAddresses");
const ethers_1 = require("ethers");
const uuid_1 = require("../../../common/src/utils/circuits/uuid");
const constants_1 = require("../../../common/src/constants/constants");
const formatCallData_1 = require("../../../common/src/utils/contracts/formatCallData");
const countries_1 = require("../../../common/src/constants/countries");
const scope_1 = require("../../../common/src/utils/scope");
const CELO_MAINNET_RPC_URL = "https://forno.celo.org";
const CELO_TESTNET_RPC_URL = "https://alfajores-forno.celo-testnet.org";
class SelfBackendVerifier {
    constructor(scope, endpoint, user_identifier_type = 'uuid', mockPassport = false) {
        this.attestationId = 1;
        this.user_identifier_type = 'uuid';
        this.targetRootTimestamp = {
            enabled: false,
            value: 0,
        };
        this.nationality = {
            enabled: false,
            value: '',
        };
        this.minimumAge = {
            enabled: false,
            value: '18',
        };
        this.excludedCountries = {
            enabled: false,
            value: [],
        };
        this.passportNoOfac = false;
        this.nameAndDobOfac = false;
        this.nameAndYobOfac = false;
        const rpcUrl = mockPassport ? CELO_TESTNET_RPC_URL : CELO_MAINNET_RPC_URL;
        const provider = new ethers_1.ethers.JsonRpcProvider(rpcUrl);
        const registryAddress = mockPassport ? contractAddresses_1.REGISTRY_ADDRESS_STAGING : contractAddresses_1.REGISTRY_ADDRESS;
        const verifyAllAddress = mockPassport ? contractAddresses_1.VERIFYALL_ADDRESS_STAGING : contractAddresses_1.VERIFYALL_ADDRESS;
        this.registryContract = new ethers_1.ethers.Contract(registryAddress, IdentityRegistryImplV1_1.registryAbi, provider);
        this.verifyAllContract = new ethers_1.ethers.Contract(verifyAllAddress, VerifyAll_1.verifyAllAbi, provider);
        this.scope = (0, scope_1.hashEndpointWithScope)(endpoint, scope);
        this.user_identifier_type = user_identifier_type;
        this.mockPassport = mockPassport;
    }
    async verify(proof, publicSignals) {
        const forbiddenCountriesListPacked = (0, formatCallData_1.packForbiddenCountriesList)(this.excludedCountries.value);
        const isValidScope = this.scope === publicSignals[constants_1.CIRCUIT_CONSTANTS.VC_AND_DISCLOSE_SCOPE_INDEX];
        const isValidAttestationId = this.attestationId.toString() ===
            publicSignals[constants_1.CIRCUIT_CONSTANTS.VC_AND_DISCLOSE_ATTESTATION_ID_INDEX];
        const vcAndDiscloseHubProof = {
            olderThanEnabled: this.minimumAge.enabled,
            olderThan: this.minimumAge.value,
            forbiddenCountriesEnabled: this.excludedCountries.enabled,
            forbiddenCountriesListPacked: forbiddenCountriesListPacked,
            ofacEnabled: [this.passportNoOfac, this.nameAndDobOfac, this.nameAndYobOfac],
            vcAndDiscloseProof: {
                a: proof.a,
                b: [
                    [proof.b[0][1], proof.b[0][0]],
                    [proof.b[1][1], proof.b[1][0]],
                ],
                c: proof.c,
                pubSignals: publicSignals,
            },
        };
        const types = [
            constants_1.revealedDataTypes.issuing_state,
            constants_1.revealedDataTypes.name,
            constants_1.revealedDataTypes.passport_number,
            constants_1.revealedDataTypes.nationality,
            constants_1.revealedDataTypes.date_of_birth,
            constants_1.revealedDataTypes.gender,
            constants_1.revealedDataTypes.expiry_date,
        ];
        if (this.minimumAge.enabled) {
            types.push(constants_1.revealedDataTypes.older_than);
        }
        if (this.passportNoOfac) {
            types.push(constants_1.revealedDataTypes.passport_no_ofac);
        }
        if (this.nameAndDobOfac) {
            types.push(constants_1.revealedDataTypes.name_and_dob_ofac);
        }
        if (this.nameAndYobOfac) {
            types.push(constants_1.revealedDataTypes.name_and_yob_ofac);
        }
        const currentRoot = await this.registryContract.getIdentityCommitmentMerkleRoot();
        const timestamp = await this.registryContract.rootTimestamps(currentRoot);
        const user_identifier = (0, uuid_1.castToUserIdentifier)(BigInt(publicSignals[constants_1.CIRCUIT_CONSTANTS.VC_AND_DISCLOSE_USER_IDENTIFIER_INDEX]), this.user_identifier_type);
        let result;
        try {
            result = await this.verifyAllContract.verifyAll(timestamp, vcAndDiscloseHubProof, types);
        }
        catch (error) {
            let errorMessage = error instanceof Error ? error.message : 'Unknown error';
            if (error && typeof error === 'object' && error.message && error.message.includes('INVALID_FORBIDDEN_COUNTRIES')) {
                errorMessage = 'The forbidden countries list in the backend does not match the list provided in the frontend SDK. Please ensure both lists are identical.';
            }
            return {
                isValid: false,
                isValidDetails: {
                    isValidScope: false,
                    isValidAttestationId: false,
                    isValidProof: false,
                    isValidNationality: false,
                },
                userId: user_identifier,
                application: this.scope,
                nullifier: publicSignals[constants_1.CIRCUIT_CONSTANTS.VC_AND_DISCLOSE_NULLIFIER_INDEX],
                credentialSubject: {},
                proof: {
                    value: {
                        proof: proof,
                        publicSignals: publicSignals,
                    },
                },
                error: errorMessage,
            };
        }
        let isValidNationality = true;
        if (this.nationality.enabled) {
            const nationality = result[0][constants_1.revealedDataTypes.nationality];
            isValidNationality = nationality === this.nationality.value;
        }
        const credentialSubject = {
            merkle_root: publicSignals[constants_1.CIRCUIT_CONSTANTS.VC_AND_DISCLOSE_MERKLE_ROOT_INDEX],
            attestation_id: this.attestationId.toString(),
            current_date: new Date().toISOString(),
            issuing_state: result[0][constants_1.revealedDataTypes.issuing_state],
            name: result[0][constants_1.revealedDataTypes.name],
            passport_number: result[0][constants_1.revealedDataTypes.passport_number],
            nationality: result[0][constants_1.revealedDataTypes.nationality],
            date_of_birth: result[0][constants_1.revealedDataTypes.date_of_birth],
            gender: result[0][constants_1.revealedDataTypes.gender],
            expiry_date: result[0][constants_1.revealedDataTypes.expiry_date],
            older_than: result[0][constants_1.revealedDataTypes.older_than].toString(),
            passport_no_ofac: result[0][constants_1.revealedDataTypes.passport_no_ofac].toString() === '1',
            name_and_dob_ofac: result[0][constants_1.revealedDataTypes.name_and_dob_ofac].toString() === '1',
            name_and_yob_ofac: result[0][constants_1.revealedDataTypes.name_and_yob_ofac].toString() === '1',
        };
        const attestation = {
            isValid: result[1] && isValidScope && isValidAttestationId && isValidNationality,
            isValidDetails: {
                isValidScope: isValidScope,
                isValidAttestationId: isValidAttestationId,
                isValidProof: result[1],
                isValidNationality: isValidNationality,
            },
            userId: user_identifier,
            application: this.scope,
            nullifier: publicSignals[constants_1.CIRCUIT_CONSTANTS.VC_AND_DISCLOSE_NULLIFIER_INDEX],
            credentialSubject: credentialSubject,
            proof: {
                value: {
                    proof: proof,
                    publicSignals: publicSignals,
                },
            },
            error: result[2],
        };
        return attestation;
    }
    setMinimumAge(age) {
        if (age <= 0) {
            throw new Error('Minimum age must be positive');
        }
        if (age > 100) {
            throw new Error('Minimum age must be at most 100 years old');
        }
        this.minimumAge = { enabled: true, value: age.toString() };
        return this;
    }
    setNationality(country) {
        this.nationality = { enabled: true, value: country };
        return this;
    }
    /**
     * Sets the list of countries to be excluded in the verification.
     * This list must exactly match the list configured in the backend.
     *
     * @param countries Array of 3-letter country codes to exclude
     * @returns This instance for method chaining
     * @throws Error if more than 40 countries are provided or if any country code is invalid
     */
    excludeCountries(...countries) {
        if (countries.length > 40) {
            throw new Error('Number of excluded countries cannot exceed 40');
        }
        // Validate country codes
        for (const country of countries) {
            if (!country || country.length !== 3) {
                throw new Error(`Invalid country code: "${country}". Country codes must be exactly 3 characters long.`);
            }
            // Check if the country code exists in the list of valid codes (additional check)
            const isValidCountry = Object.values(countries_1.commonNames).some(name => name === country || country in countries_1.commonNames);
            if (!isValidCountry) {
                throw new Error(`Unknown country code: "${country}". Please use valid 3-letter ISO country codes.`);
            }
        }
        this.excludedCountries = { enabled: true, value: countries };
        return this;
    }
    enablePassportNoOfacCheck() {
        this.passportNoOfac = true;
        return this;
    }
    enableNameAndDobOfacCheck() {
        this.nameAndDobOfac = true;
        return this;
    }
    enableNameAndYobOfacCheck() {
        this.nameAndYobOfac = true;
        return this;
    }
}
exports.SelfBackendVerifier = SelfBackendVerifier;
